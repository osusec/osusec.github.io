<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65 crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js integrity=sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4 crossorigin=anonymous></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Mulish:wght@300;600;800&family=Open+Sans:wght@400;600&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css integrity="sha512-q3eWabyZPc1XTCmF+8/LuE1ozpg5xxn7iO89yfSOd5/oKvyqLngoNGsx8jq92Y8eXJ/IRxQbEC+FGSYxtk2oiw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/solid.min.css integrity="sha512-LopA1sokwAW/FNZdP+/5q8MGyb9CojL1LTz8JMyu/8YZ8XaCDn1EOm6L7RWIIOHRM7K4jwnHuOmyLZeeeYxSOA==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/caseyhates.css><title>UTCTF 2019 - Crackme | OSU Security Club</title></head><body id=background-img style=background-image:url(/blog/utctf-2019-crackme.jpg);background-position:50%><nav class="navbar navbar-expand-lg px-lg-5 py-lg-2 fixed-top topbar bg-light"><div class="container-fluid flex-nowrap px-lg-5"><a class=navbar-brand href=/><img src=/osusec-banner.png class=img-fluid alt=OSUSEC width=450px></a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"></ul><ul class="navbar-nav d-flex mb-2 mb-lg-0"><li class="nav-item px-1"><a class="nav-link highlight-orange-nav" href=/>Home</a></li><li class="nav-item px-1 dropdown"><a class="nav-link text-black dropdown-toggle" href=# role=button data-bs-toggle=dropdown aria-expanded=false>About</a><ul class=dropdown-menu><li><a class="dropdown-item topbar topbar-drop shadow-none" href=/about/>Who We Are</a></li><li><a class="dropdown-item topbar topbar-drop shadow-none" href=/club-constitution/>Club Constitution</a></li></ul></li><li class="nav-item px-1"><a class="nav-link highlight-orange-nav" href=/calendar/>Calendar</a></li><li class="nav-item px-1"><a class="nav-link highlight-orange-nav" href=/blog/>Blog</a></li><li class="nav-item px-1"><a class="nav-link highlight-orange-nav" href=/ctf-league/>CTF League</a></li><li class="nav-item px-1"><a class="nav-link highlight-orange-nav" href=/accomplishments/>Accomplishments</a></li><li class="nav-item px-1"><a class="nav-link highlight-orange-nav" href=/resources/>Resources</a></li></ul></div></div></nav><main id=main><div id=home-jumbotron class="jumbotron text-center hero-content infopage-hero d-flex flex-column justify-content-center"><h1 class="hero-title py-1">UTCTF 2019 - Crackme</h1></div><div class="bg-light justify-content-center infopage-content" style=min-height:60vh><div class=blog-content><h1 class=blog-title>UTCTF 2019 - Crackme</h1><div class="blog-subtext d-flex flex-wrap"><p class=blog-subtext-item><i class="fa fa-user"></i> Zander Work</p><p class=blog-subtext-item><i class="fa fa-folder"></i> Tags</p><p class=blog-subtext-item><i class="fa fa-calendar"></i> <time datetime=2019-03-11>Mar 11, 2019</time></p></div><img src=/blog/utctf-2019-crackme.jpg alt class=blogcard-img><div class=blog-content-text><p>This was a 1200 point reversing challenge (tied for highest point value in the category). Here’s the description:</p><p><img src=/blog/utctf-2019-crackme-ctfd.png alt="Screenshot of UTCTF&amp;rsquo;s CTFd for the Crackme challenge"></p><p>This what we see when we run the binary:</p><pre tabindex=0><code>$ ./crackme
Please enter the correct password.
&gt;pls
Incorrect password. utflag{wrong_password_btw_this_is_not_the_flag_and_if_you_submit_this_i_will_judge_you}
</code></pre><p>Let’s take a look at the code in IDA Pro:</p><p><img src=/blog/utctf-2019-crackme-decompilation.png alt="Screenshot of main decompliation in IDA Pro"></p><p>Here’s what the decompilation shows:</p><ul><li>Read in 64 bytes from stdin</li><li>Call divide(32, 0), and save the return value to v4</li><li>xor our input at index v4 with 8</li><li>Replace a few characters of our input with ‘D’</li><li>xor each character in our input with 0x27</li></ul><p>Now we see “stuff[j] = stuff2[202 – j] ^ (stuff[j] – 1);”. stuff and stuff2 live in the .data section (along with test). The loop applies that operation to each of the first 202 bytes of stuff (there are some null bytes afterwards for padding), and then calls it. This is quite cool, and not something I have seen in a reversing challenge before. The binary is modifying it’s own data to create a new function, and then execute it to add additional layers of obfuscation.</p><p>Before I start working through that obfuscated function, I took a look at divide():</p><p><img src=/blog/utctf-2019-crackme-fastcall_divide.png alt="Screenshot of IDA Pro decompilation of the divide function"></p><p>Based on the function call “divide(32, 0)”, it does indeed do a divide by zero, which throws an exception, further messing with our debugging and analysis. I ended up just skipping it and not worrying about it, which worked out in the end.</p><p>In order to analyze that obfuscated function in .data, I needed to do a few things:</p><pre><code>Extract stuff and stuff2 from the binary
Write a program to apply the deobfuscation to stuff
Disassemble/decompile the resulting function for analysis
</code></pre><p>I used gdb to get extract the two variables. Here’s what that looks like for stuff:</p><pre tabindex=0><code>$ gdb crackme
Reading symbols from crackme…(no debugging symbols found)…done.
gdb-peda$ x/52x &amp;stuff
0x602090 :   0xed592513      0x908d3643      0x6bd01bc6      0xc3112c86
0x6020a0 :   0xb55cd9d3      0x92a40224      0x4566fb3a      0x74a5731d
0x6020b0 :   0xccea82e8      0xd125398a      0x2a5105e7      0x67b7a235
0x6020c0 :   0x99a1886b      0xf224a523      0x06eb4f61      0x816685bd
0x6020d0 :   0xd979c55b      0x841c39e4      0xb7c6288c      0xc599716e
0x6020e0 :   0xc550b65d      0xed393d86      0xc417dd7a      0x96681e07
0x6020f0 :   0x1ae03766      0x52637a30      0x05718f9f      0x8c4c3973
0x602100 :   0xcc581405      0xa2db617f      0x9993db2b      0xc7ebb606
0x602110 :   0x182b63b3      0xaa4e0a50      0x8192d259      0x7ae97ae7
0x602120 :   0xe479bea9      0x53e79c45      0x9c26894b      0x9ea75bf8
0x602130 :   0xadf5e45d      0x41aede98      0xd230dd97      0xfb81fd17
0x602140 :   0x4ac0d10a      0x735f3ee8      0xfcc0a13c      0x839c7ffd
0x602150 :   0xff03fb9b      0x4be73391      0x00c93d31      0x00000000
gdb-peda$ dump memory stuff.bin 0x602090 (0x602090 + 204)
</code></pre><p>This writes 204 bytes after 0x602090 to stuff.bin. I did the same thing for stuff2, and then wrote a C program to apply the xor operation and dump it back to disk. You can see the program <a href=https://github.com/zzzanderw/ctf-writeups/blob/master/utctf2019/crackme/convert.c>here</a>.</p><p>With that in hand, we were able to pull out a function that I wanted to decompile. While I would not recommend doing it this way, I wrote a Python program (which you can see <a href=https://github.com/zzzanderw/ctf-writeups/blob/master/utctf2019/crackme/replace.py>here</a>) that replaced the main() function of the original binary with the new function and dumped it to a new binary so I could load it into IDA:</p><p><img src=/blog/utctf-2019-crackme-newmain.png alt="Screenshot of new main injected into the program and decompiled by IDA Pro"></p><p>While IDA didn’t do a great job parsing the function since it thought it was main, it showed us the logic. The function applies an xor to each byte with the loop counter plus 51, simple enough.</p><p>At this point, I had enough information to write another Python script (which you can see here) to build the password based on the test value it gets compared against. I extracted test using the same method I showed above for stuff, and did the following things:</p><ul><li>Read in the test data</li><li>Undo the deobfuscated stuff function</li><li>Undo the 0x27 xor</li></ul><p>That script provided this output:</p><pre tabindex=0><code>$ ./solve.py 
&#39;1_hav3_1nf0rmat10n_that_w1ll_lead_t0_th3_arr3st\x1b0f_cspp3rstick6U&#39;
</code></pre><p>There are some bad characters in here, which is due to some extra xors I didn’t want to mess with, so I just guessed and got lucky on what the password was supposed to be:</p><pre tabindex=0><code>$ ./crackme
Please enter the correct password.
&gt;1_hav3_1nf0rmat10n_that_w1ll_lead_t0_th3_arr3st_0f_c0pp3rstick6               
Correct Password!
</code></pre><p>The flag is <strong>utflag{1_hav3_1nf0rmat10n_that_w1ll_lead_t0_th3_arr3st_0f_c0pp3rstick6}</strong>.</p><p><em>Some extra info:</em></p><p>If you wanted to analyze this dynamically, you would have had some trouble:</p><pre tabindex=0><code>$ gdb crackme
Reading symbols from crackme…(no debugging symbols found)…done.
gdb-peda$ b *main
Breakpoint 1 at 0x400af0
gdb-peda$ r
Starting program: /mnt/hgfs/sec/utctf19/crackme/crackme 
[Thread debugging using libthread_db enabled]
Using host libthread_db library &#34;/lib/x86_64-linux-gnu/libthread_db.so.1&#34;.
[Inferior 1 (process 5869) exited with code 01]
Warning: not running or target is remote
gdb-peda$ 
</code></pre><p>Why doesn’t our breakpoint get hit?</p><p>This is due to a sneaky move by the challenge author by putting a ptrace() call in a function called _csu_init(), which causes debugging to be unsuccessful. If there is more than one trace applied to the program, it exits:</p><p><img src=/blog/utctf-2019-crackme-ptrace.png alt="Screenshot of IDA Pro decompilation of the function that calls ptrace"></p><p>You can patch out the ptrace call with nops, which would allow you to dynamically analyze this. I patched the binary while I was working on the challenge, but ended up just doing it statically.</p></div></div></div></main><footer class="border-top py-4 bg-light"><div class="text-muted text-center"><p>© 2023 OSU Security Club.</p><p>Contact us at: <a href=mailto:security.clubs@oregonstate.edu class="text-reset text-decoration-none fw-bold">security.clubs@oregonstate.edu</a></p></div></footer></body></html>