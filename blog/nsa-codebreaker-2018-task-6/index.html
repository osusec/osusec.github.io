<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65 crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js integrity=sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4 crossorigin=anonymous></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Mulish:wght@300;600;800&family=Open+Sans:wght@400;600&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css integrity="sha512-q3eWabyZPc1XTCmF+8/LuE1ozpg5xxn7iO89yfSOd5/oKvyqLngoNGsx8jq92Y8eXJ/IRxQbEC+FGSYxtk2oiw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/solid.min.css integrity="sha512-LopA1sokwAW/FNZdP+/5q8MGyb9CojL1LTz8JMyu/8YZ8XaCDn1EOm6L7RWIIOHRM7K4jwnHuOmyLZeeeYxSOA==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/caseyhates.css><title>NSA Codebreaker 2018 - Task 6 | OSU Security Club</title></head><body id=background-img style=background-image:url(/blog/nsa-codebreaker-2018-task-6.jpg);background-position:50%><nav class="navbar navbar-expand-lg px-lg-5 py-lg-2 fixed-top topbar bg-light"><div class="container-fluid flex-nowrap px-lg-5"><a class=navbar-brand href=/><img src=/osusec-banner.png class=img-fluid alt=OSUSEC width=450px></a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"></ul><ul class="navbar-nav d-flex mb-2 mb-lg-0"><li class="nav-item px-1"><a class="nav-link highlight-orange-nav" href=/>Home</a></li><li class="nav-item px-1 dropdown"><a class="nav-link text-black dropdown-toggle" href=# role=button data-bs-toggle=dropdown aria-expanded=false>About</a><ul class=dropdown-menu><li><a class="dropdown-item topbar topbar-drop shadow-none" href=/about/>Who We Are</a></li><li><a class="dropdown-item topbar topbar-drop shadow-none" href=/club-constitution/>Club Constitution</a></li><li><a class="dropdown-item topbar topbar-drop shadow-none" href=/wicys/>WiCyS</a></li></ul></li><li class="nav-item px-1"><a class="nav-link highlight-orange-nav" href=/calendar/>Calendar</a></li><li class="nav-item px-1"><a class="nav-link highlight-orange-nav" href=/blog/>Blog</a></li><li class="nav-item px-1"><a class="nav-link highlight-orange-nav" href=/ctf-league/>CTF League</a></li><li class="nav-item px-1"><a class="nav-link highlight-orange-nav" href=/accomplishments/>Accomplishments</a></li><li class="nav-item px-1"><a class="nav-link highlight-orange-nav" href=/resources/>Resources</a></li></ul></div></div></nav><main id=main><div id=home-jumbotron class="jumbotron text-center hero-content infopage-hero d-flex flex-column justify-content-center"><h1 class="hero-title py-1">NSA Codebreaker 2018 - Task 6</h1></div><div class="bg-light justify-content-center infopage-content" style=min-height:60vh><div class=blog-content><h1 class=blog-title>NSA Codebreaker 2018 - Task 6</h1><div class="blog-subtext d-flex flex-wrap"><p class=blog-subtext-item><i class="fa fa-user"></i> Andrew Quach</p><p class=blog-subtext-item><i class="fa fa-folder"></i> Tags</p><p class=blog-subtext-item><i class="fa fa-calendar"></i> <time datetime=2019-01-16>Jan 16, 2019</time></p></div><img src=/blog/nsa-codebreaker-2018-task-6.jpg alt class=blogcard-img><div class=blog-content-text><p><strong>Loophole – (Smart-Contract Development; Vulnerability Analysis; Exploit Development)</strong></p><p>Task 6 has us exploit a loophole in the smart-contracts to recover the decryption key without spending any ether (not including transaction costs). We are given the source for three smart contracts: <a href=https://gist.github.com/Aqcurate/1759ad80cf1d443d23a20fb7e012d38d>the Escrow contract, the Ransom contract, and the Registry contract.</a></p><h4 id=decryption-overview>Decryption Overview</h4><p>Let’s first look at the intended method of recovering the decryption key.</p><p><img src=/blog/nsa-codebreaker-2018-task-6-escrow-contract.png alt="Diagram of the Escrow Contract"></p><ol><li>From the Escrow contract, the victim calls <strong>payRansom()</strong> to pay the ransom amount. The victim is marked as having paid.</li><li>The <strong>payRansom()</strong> function calls <strong>requestKey()</strong> in the Ransom contract.</li><li>The <strong>requestKey()</strong> function in the Ransom contract calls <strong>decryptKey()</strong> in the Escrow contract.</li><li>The <strong>decryptKey()</strong> function in the Escrow contract emits a <strong>DecryptEvent</strong>.</li><li>An off-chain oracle processes this <strong>DecryptEvent</strong>, calling <strong>decryptCallback()</strong>. If the processing is successful, the Ransom contract is marked as fulfilled. Otherwise, the victim gets a refund.</li><li>The victim can now call <strong>getDecryptionKey()</strong> to get their decryption key.</li></ol><h4 id=scanning-for-vulnerabilities>Scanning for Vulnerabilities</h4><p>Let’s look at the entry point for this decryption process: <strong>payRansom()</strong>.</p><pre tabindex=0><code>function payRansom(uint id, string encFile) external restrictSenderToVictim(id) payable {
    Victim storage vicInfo = victimMap[id];
    Ransom ransom = Ransom(vicInfo.ransomAddr);

    if (msg.value &gt;= vicInfo.ransomAmount &amp;&amp; !ransom.isFulFilled()) {
            
        escrowMap[id] += msg.value;
        encFileMap[id] = encFile;
        vicToPayerMap[id] = msg.sender;
        ransom.requestKey(); 
    } else {
        emit BadPaymentEvent(id);
    }
}
</code></pre><p>If we want to start this decryption process without paying, we must bypass the <strong>msg.value >= vicInfo.ransomAmount</strong> condition. Since spoofing <strong>msg.value</strong> isn’t an option, we can instead try to find a way to modify <strong>vicInfo.ransomAmount</strong>, setting it to zero.</p><pre tabindex=0><code>function registerRansom(uint ransomAmount,
                        uint victimId, 
                        address victimAddr) external onlyAuthenticated(msg.sender)  { 
    victimMap[victimId] = Victim(victimId, ransomAmount, victimAddr, msg.sender);
}
</code></pre><p>We find that <strong>vicInfo.ransomAmount</strong> is set when the ransom contract is registered. Unfortunately, we do not the permissions to register our own ransom contract since we are not authenticated. So, the natural question that emerges: how is a contract authenticated?</p><h4 id=registering-ransom-contracts>Registering Ransom Contracts</h4><p>Here is quick overview of the deployment process for ransom contracts.</p><p><img src=/blog/nsa-codebreaker-2018-task-6-ransom-register.png alt="Diagram of Registration of Escrow Contract"></p><ol><li>In the constructor of the Ransom contract, the <strong>registerVictim()</strong> function of the Registry contract is called with two arguments: the victim ID and the authentication token.</li><li>The <strong>registerVictim()</strong> function emits an <strong>AuthEvent</strong> with four arguments: the victim ID, the Ransom contract address, the authentication token, and the person who deployed the Ransom contract.</li><li>An off-chain oracle processes this <strong>AuthEvent</strong>, calling <strong>authCallback()</strong> in the Registry contract.</li><li>The <strong>authCallback()</strong> function in the Registry contract calls the <strong>authCallback()</strong> functions in the Escrow and Ransom contracts.</li><li>The Escrow contract’s <strong>authCallback()</strong> function authenticates the Ransom contract’s address if the result is successful.</li><li>The Ransom contract’s <strong>authCallback()</strong> function calls the <strong>registerRansom()</strong> function in the Escrow contract if the result is successful.</li></ol><h4 id=deploying-a-custom-ransom-contract-attempt-1>Deploying a Custom Ransom Contract (Attempt 1)</h4><p>The key to authenticating a ransom contract is emitting an <strong>AuthEvent</strong> which the off-chain oracle deems successful. But what constitutes as successful?</p><pre tabindex=0><code>function registerVictim(uint id, uint authToken) external returns (bool) {
    if (MAX_PENDING_AUTH_REQUESTS &gt; 0 &amp;&amp; pendingAuthCount == MAX_PENDING_AUTH_REQUESTS) {
        return false;
    }
    pendingAuthCount++;
    authMap[id] = VictimInfo(id, msg.sender, 0);

    emit AuthEvent(id, msg.sender, authToken, tx.origin);

    return true;
}
</code></pre><p>We can quickly rule out the first two parameters: the victim ID and the Ransom contract address. These two parameters likely have no impact on the return of <strong>AuthEvent</strong>. The victim ID is just going to be set to our own ID and the new Ransom contract address can’t really be controlled.</p><p>But of the two remaining degrees of freedom, the use of <strong>tx.origin</strong> particularly eye-catching. <a href=https://solidity.readthedocs.io/en/v0.4.24/security-considerations.html#tx-origin>Using tx.origin as a means for checking authorization of ownership is a well known vulnerability.</a> Since the oracle initiates a transaction every time it performs a callback, we can trick the oracle into emitting the <strong>AuthEvent</strong> for us.</p><pre tabindex=0><code>function authCallback(address _escrowAddr, bool authResult) external restrictSenderToRegistry {
    authenticated = authResult;
    if (authResult == true){
        escrowAddr = _escrowAddr;

        // 0 ether ransom default
        Escrow(escrowAddr).registerRansom(0 ether, victimId, victimAddr);
    } else {
        Registry(registryAddr).registerVictim(victimId, authToken);
    }
}
</code></pre><p>Although this is definitely sloppy (potential infinite loop until the gas runs out), re-registering the victim in the callback function allows us to use the oracle’s address as the transaction origin.</p><p>Unfortunately for us, on further investigation, the <strong>tx.origin</strong> parameter does not seem to play a part in the authentication process. In fact, if we scan the blockchain for events emitted, we can see the origin address used in the original Ransom contract’s authentication event is something we cannot replicate (without phishing).</p><p><strong>Original AuthEvent:</strong></p><p>0x9f7727801209b9f92e263cca5d8c3bdf26eedcbf8abb375bcbd101d57acb354d0000000000000000000000002b438d42631256b6e16d9709f176b9f3b1fc3ece0000000000000000000000000000000000000000000000000000000000076c7f000000000000000000000000<strong>63d85378eb4d57c4ae14f6a39b05e495de08b1a8</strong></p><p><strong>AuthEvent w/ tx.origin as our own address:</strong></p><p>0x9f7727801209b9f92e263cca5d8c3bdf26eedcbf8abb375bcbd101d57acb354d0000000000000000000000004a722e89bea34984647fefec01f1eccecd9d5afc000000000000000000000000000000000000000000000000000000000007c99b000000000000000000000000<strong>7d8687379ea4882b3b279bbc5c97b47ae73cb0e8</strong></p><p><strong>AuthEvent w/ tx.origin as the oracle’s address:</strong></p><p>0x9f7727801209b9f92e263cca5d8c3bdf26eedcbf8abb375bcbd101d57acb354d000000000000000000000000237d008839b32a959e845d5ba94f10a6d142a1970000000000000000000000000000000000000000000000000000000000076c7f000000000000000000000000<strong>191b13d28df6b574275405e485dfc0f6794ad831</strong></p><p>(Notice the <strong>(id, msg.sender, authToken, tx.origin)</strong> tuple in the authentication event data.)</p><h4 id=deploying-a-custom-ransom-contract-attempt-2>Deploying a Custom Ransom Contract (Attempt 2)</h4><p>So, the authentication event depends solely on the authentication code. But how is this authentication code generated?</p><p>Luckily for us, the one time password (OTP) generation function was leaked in a previously given shared object file (libclient_crypt.so).</p><p><img src=/blog/nsa-codebreaker-2018-task-6-asm.png alt="Screenshot of disassembly of OTP generation function"></p><p>Reversing this function nets us the following code.</p><pre tabindex=0><code>#include &lt;openssl/evp.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main() {
    const char key[21] = {&#39;\xed&#39;, &#39;{&#39;, &#39;\xe8&#39;, &#39;e&#39;, &#39;\x89&#39;, &#39;D&#39;, &#39;K&#39;,
                                   &#39;\xcd&#39;, &#39;\xd0&#39;, &#39;\xe1&#39;, &#39;\x1b&#39;, &#39;n&#39;, &#39;\xd3&#39;, &#39;\x02&#39;,
                                   &#39;,&#39;, &#39;Z&#39;, &#39;W&#39;, &#39;\xc3&#39;, &#39;p&#39;, &#39;\xd3&#39;, &#39;\x00&#39;};
    long now = time(NULL);

    // Time seed will update every 30 seconds
    unsigned long long seed = (unsigned long long) __builtin_bswap32((now / 30)) &lt;&lt; 32;

    const EVP_MD* sha1 = EVP_sha1();
    EVP_MD_CTX* mdctx = EVP_MD_CTX_create();
    EVP_PKEY* pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, key, 20);
    EVP_DigestSignInit(mdctx, NULL, sha1, NULL, pkey);
    EVP_DigestUpdate(mdctx, &amp;seed, 8);

    size_t siglen = 0;
    unsigned char sig[20];
    int res = EVP_DigestSignFinal(mdctx, sig, &amp;siglen);

    int offset = sig[siglen-1] &amp; 0xf;
    unsigned int otp = ((
                (sig[offset+1] &lt;&lt; 16) + sig[offset+3] + (sig[offset+0] &lt;&lt; 24) + (sig[offset+2] &lt;&lt; 8)
                ) &amp; 0x7FFFFFFF
                ) % 0xF4240;

    printf(&#34;OTP: %d\n&#34;, otp);
}
</code></pre><p>Note that the key array is the secret key (found in task 2) base-32 decoded.</p><p>We can now deploy any Ransom contract we want. The arguments for the Ransom contract constructor (e.g. _encKey, _registryAddr) can be found using the same method shown in task 4.</p><p><img src=/blog/nsa-codebreaker-2018-task-6-noransom.png alt="Screenshot of deploying a fake ransom contract"></p><p><img src=/blog/nsa-codebreaker-2018-task-6-noransom2.png alt="Screenshot of the fake ransom contract, completed"></p><h4 id=finishing-off-the-exploit>Finishing Off the Exploit</h4><p>Now, we can make a simple modification in our new Ransom contract—changing the Ransom amount from 100 ether to 0 ether.</p><pre tabindex=0><code>uint constant RANSOMAMOUNT = 0 ether; //!&lt; The ransom amount the victim must pay
</code></pre><p>When we call payRansom() with no ether sent and the correct arguments, then call getDecryptionKey(), we receive the decryption key—no payment necessary!</p><p><img src=/blog/nsa-codebreaker-2018-task-6-payransom.png alt="Screenshot of making a payment on the fake ransom contract and extraction of flag"></p><p>By exploiting a weakness in the off-chain contract validation system, we were able to bypass the ransom.</p><h4 id=submission-details>Submission Details</h4><p><strong>Decryption Key:</strong> 0xc2f5676c865a230f72e9bc36bdf90e4dd9a2de697f21267213147ebefbeef7b5</p><p><strong>Transaction Hash:</strong> 0x9c23c90b7a6d143b23efe96555e846b289a937b69dcfe75cdb3f9a9529fd7bc9</p><p><img src=/blog/nsa-codebreaker-2018-task-6-finished.png alt="Screenshot of Task 6 on NSA Codebreaker Challenge website complete"></p></div></div></div></main><footer class="border-top py-4 bg-light"><div class="text-muted text-center"><p>© <script>document.write((new Date).getFullYear())</script>OSU Security Club.</p><p>Contact us at:
<a href=mailto:security.clubs@oregonstate.edu class="text-reset text-decoration-none fw-bold">security.clubs@oregonstate.edu</a></p><div class=mt-3><div class="d-flex justify-content-center gap-3"><a href=https://www.instagram.com/dam.secure/ target=_blank class=text-reset title=Instagram><i class="fab fa-instagram" aria-hidden=true></i></a>
<a href=https://x.com/OSUSEC target=_blank class=text-reset title=Twitter><i class="fab fa-twitter" aria-hidden=true></i></a></div></div></div></footer></body></html>